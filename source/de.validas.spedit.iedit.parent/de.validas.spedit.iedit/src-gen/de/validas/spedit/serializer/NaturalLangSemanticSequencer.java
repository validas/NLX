/*
 * generated by Xtext 2.16.0
 */
package de.validas.spedit.serializer;

import com.google.inject.Inject;
import de.validas.spedit.naturalLang.Array;
import de.validas.spedit.naturalLang.BracketSentence;
import de.validas.spedit.naturalLang.ChapterSentence;
import de.validas.spedit.naturalLang.EString;
import de.validas.spedit.naturalLang.Elements;
import de.validas.spedit.naturalLang.EmailAT;
import de.validas.spedit.naturalLang.ExtBracketSentence;
import de.validas.spedit.naturalLang.FootNote;
import de.validas.spedit.naturalLang.Formula;
import de.validas.spedit.naturalLang.IgnoredText;
import de.validas.spedit.naturalLang.ItWord;
import de.validas.spedit.naturalLang.ListSentence;
import de.validas.spedit.naturalLang.MailAdress;
import de.validas.spedit.naturalLang.Model;
import de.validas.spedit.naturalLang.NaturalLangPackage;
import de.validas.spedit.naturalLang.ParagraphBlock;
import de.validas.spedit.naturalLang.Quote;
import de.validas.spedit.naturalLang.Sentence;
import de.validas.spedit.naturalLang.SentenceChain;
import de.validas.spedit.naturalLang.ShortCut;
import de.validas.spedit.naturalLang.SimpleUnit;
import de.validas.spedit.naturalLang.SubSentence;
import de.validas.spedit.naturalLang.Symbols;
import de.validas.spedit.naturalLang.Table;
import de.validas.spedit.naturalLang.TableColumnSeparator;
import de.validas.spedit.naturalLang.TableLine;
import de.validas.spedit.naturalLang.TableRow;
import de.validas.spedit.naturalLang.Unit;
import de.validas.spedit.naturalLang.UrlAdress;
import de.validas.spedit.naturalLang.Word;
import de.validas.spedit.services.NaturalLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class NaturalLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NaturalLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NaturalLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NaturalLangPackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case NaturalLangPackage.BRACKET_SENTENCE:
				sequence_BracketSentence(context, (BracketSentence) semanticObject); 
				return; 
			case NaturalLangPackage.CHAPTER_SENTENCE:
				if (rule == grammarAccess.getChapterSentenceRule()) {
					sequence_ChapterSentence(context, (ChapterSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceTypeRule()) {
					sequence_ChapterSentence_SentenceType(context, (ChapterSentence) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.ESTRING:
				if (rule == grammarAccess.getShortcutGenRule()) {
					sequence_ShortcutGen(context, (EString) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShortcutLibRule()) {
					sequence_ShortcutLib(context, (EString) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.ELEMENTS:
				sequence_New_Line(context, (Elements) semanticObject); 
				return; 
			case NaturalLangPackage.EMAIL_AT:
				sequence_EmailAT(context, (EmailAT) semanticObject); 
				return; 
			case NaturalLangPackage.EXT_BRACKET_SENTENCE:
				if (rule == grammarAccess.getExtBracketSentenceCRule()) {
					sequence_ExtBracketSentenceC(context, (ExtBracketSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExtBracketSentenceRule()) {
					sequence_ExtBracketSentence(context, (ExtBracketSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNoNElementRule()
						|| rule == grammarAccess.getBracketsRule()
						|| rule == grammarAccess.getNoNElementXRule()
						|| rule == grammarAccess.getNoNElementX2Rule()
						|| rule == grammarAccess.getElementsRule()
						|| rule == grammarAccess.getAllElementsRule()) {
					sequence_ExtBracketSentence_ExtBracketSentenceC(context, (ExtBracketSentence) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.FOOT_NOTE:
				sequence_FootNote(context, (FootNote) semanticObject); 
				return; 
			case NaturalLangPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case NaturalLangPackage.IGNORED_TEXT:
				sequence_IgnoredText(context, (IgnoredText) semanticObject); 
				return; 
			case NaturalLangPackage.IT_WORD:
				sequence_ItWord(context, (ItWord) semanticObject); 
				return; 
			case NaturalLangPackage.LIST_SENTENCE:
				sequence_ListSentence(context, (ListSentence) semanticObject); 
				return; 
			case NaturalLangPackage.MAIL_ADRESS:
				sequence_MailAdress(context, (MailAdress) semanticObject); 
				return; 
			case NaturalLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case NaturalLangPackage.PARAGRAPH_BLOCK:
				if (rule == grammarAccess.getParagraphBlockRule()) {
					sequence_ParagraphBlock(context, (ParagraphBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceTypeRule()) {
					sequence_ParagraphBlock_SentenceType(context, (ParagraphBlock) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.QUOTE:
				sequence_Quote(context, (Quote) semanticObject); 
				return; 
			case NaturalLangPackage.SENTENCE:
				if (rule == grammarAccess.getFreeSentenceRule()) {
					sequence_FreeSentence(context, (Sentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLineSentenceRule()) {
					sequence_LineSentence(context, (Sentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceXRule()) {
					sequence_SentenceX(context, (Sentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceRule()) {
					sequence_Sentence(context, (Sentence) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.SENTENCE_CHAIN:
				if (rule == grammarAccess.getLineSentenceChainRule()) {
					sequence_LineSentenceChain(context, (SentenceChain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSentenceChainXRule()) {
					sequence_SentenceChainX(context, (SentenceChain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockElementRule()
						|| rule == grammarAccess.getSentenceChainRule()) {
					sequence_SentenceChain(context, (SentenceChain) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.SHORT_CUT:
				sequence_ShortCut(context, (ShortCut) semanticObject); 
				return; 
			case NaturalLangPackage.SIMPLE_UNIT:
				sequence_SimpleUnit(context, (SimpleUnit) semanticObject); 
				return; 
			case NaturalLangPackage.SUB_SENTENCE:
				if (rule == grammarAccess.getFreeSubSentenceRule()) {
					sequence_FreeSubSentence(context, (SubSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLineSubSentenceRule()) {
					sequence_LineSubSentence(context, (SubSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSubSentenceRule()) {
					sequence_SubSentence(context, (SubSentence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTrailSubSentenceRule()) {
					sequence_TrailSubSentence(context, (SubSentence) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.SYMBOLS:
				if (rule == grammarAccess.getNoNElementRule()
						|| rule == grammarAccess.getNoNElementXRule()
						|| rule == grammarAccess.getNoNElementX2Rule()
						|| rule == grammarAccess.getSymbolsXRule()) {
					sequence_SymbolsX(context, (Symbols) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSymbolsRule()) {
					sequence_Symbols(context, (Symbols) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementsRule()
						|| rule == grammarAccess.getAllElementsRule()) {
					sequence_Symbols_SymbolsX(context, (Symbols) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.TABLE:
				if (rule == grammarAccess.getSentenceTypeRule()) {
					sequence_SentenceType_Table(context, (Table) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableRule()) {
					sequence_Table(context, (Table) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.TABLE_COLUMN_SEPARATOR:
				sequence_TableColumnSeparator(context, (TableColumnSeparator) semanticObject); 
				return; 
			case NaturalLangPackage.TABLE_LINE:
				sequence_TableLine(context, (TableLine) semanticObject); 
				return; 
			case NaturalLangPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case NaturalLangPackage.UNIT:
				if (rule == grammarAccess.getNoNElementX2Rule()
						|| rule == grammarAccess.getElementsRule()
						|| rule == grammarAccess.getAllElementsRule()) {
					sequence_ChapterAlpha_HashNumber_SimpleUnit_Unit(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getChapterAlphaRule()) {
					sequence_ChapterAlpha(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getChapter_Unit_HIRule()) {
					sequence_Chapter_Unit_HI(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getChapter_Unit_LowRule()) {
					sequence_Chapter_Unit_Low(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNoNElementRule()
						|| rule == grammarAccess.getNoNElementXRule()
						|| rule == grammarAccess.getHashNumberRule()) {
					sequence_HashNumber(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleUnitRule()) {
					sequence_SimpleUnit(context, (Unit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitRule()) {
					sequence_Unit(context, (Unit) semanticObject); 
					return; 
				}
				else break;
			case NaturalLangPackage.URL_ADRESS:
				sequence_UrlAdress(context, (UrlAdress) semanticObject); 
				return; 
			case NaturalLangPackage.WORD:
				if (rule == grammarAccess.getWordShortRule()) {
					sequence_WordShort(context, (Word) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNoNElementRule()
						|| rule == grammarAccess.getNoNElementX2Rule()
						|| rule == grammarAccess.getWordRule()) {
					sequence_Word(context, (Word) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNoNElementXRule()
						|| rule == grammarAccess.getElementsRule()
						|| rule == grammarAccess.getAllElementsRule()) {
					sequence_Word_WordShort(context, (Word) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NoNElement returns Array
	 *     NoNElementX returns Array
	 *     NoNElementX2 returns Array
	 *     Elements returns Array
	 *     AllElements returns Array
	 *     Array returns Array
	 *
	 * Constraint:
	 *     ((name+=ItWord | name+=Word) parameters+=ExtBracketSentence+)
	 */
	protected void sequence_Array(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns BracketSentence
	 *     Brackets returns BracketSentence
	 *     NoNElementX returns BracketSentence
	 *     NoNElementX2 returns BracketSentence
	 *     Elements returns BracketSentence
	 *     AllElements returns BracketSentence
	 *     BracketSentence returns BracketSentence
	 *
	 * Constraint:
	 *     (
	 *         open=BR_O 
	 *         (brackedSentences+=FreeSentence (separator+=FullStop brackedSentences+=FreeSentence)*)? 
	 *         (separator+=DOT | separator+=FS | separator+=FullStop)? 
	 *         close=BR_CL
	 *     )
	 */
	protected void sequence_BracketSentence(ISerializationContext context, BracketSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElementX2 returns Unit
	 *     Elements returns Unit
	 *     AllElements returns Unit
	 *
	 * Constraint:
	 *     (
	 *         (signature=MINUS? value+=Number (unit=CURRENCY | unit=ID | unit=PERCENT)?) | 
	 *         value+=chapterNum | 
	 *         ((sign=HASH | sign=PARAGR) value+=Number) | 
	 *         ((value+=ID_C | value+=ALL_ALPHA) value+=DOT value+=ChapterIntermediate ((value+=DOT | value+=MINUS) value+=ChapterIntermediate)*)
	 *     )
	 */
	protected void sequence_ChapterAlpha_HashNumber_SimpleUnit_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChapterAlpha returns Unit
	 *
	 * Constraint:
	 *     ((value+=ID_C | value+=ALL_ALPHA) value+=DOT value+=ChapterIntermediate ((value+=DOT | value+=MINUS) value+=ChapterIntermediate)*)
	 */
	protected void sequence_ChapterAlpha(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChapterSentence returns ChapterSentence
	 *
	 * Constraint:
	 *     ((chapterNumber=Chapter_Unit_Low | chapterNumber=ChapterAlpha | chapterNumber=Chapter_Unit_HI) Headline=LineSentenceChain)
	 */
	protected void sequence_ChapterSentence(ISerializationContext context, ChapterSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceType returns ChapterSentence
	 *
	 * Constraint:
	 *     ((chapterNumber=Chapter_Unit_Low | chapterNumber=ChapterAlpha | chapterNumber=Chapter_Unit_HI) Headline=LineSentenceChain pEnd=Paragraph)
	 */
	protected void sequence_ChapterSentence_SentenceType(ISerializationContext context, ChapterSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Chapter_Unit_HI returns Unit
	 *
	 * Constraint:
	 *     value+=chapterNum
	 */
	protected void sequence_Chapter_Unit_HI(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Chapter_Unit_Low returns Unit
	 *
	 * Constraint:
	 *     value+=decimalNumEN
	 */
	protected void sequence_Chapter_Unit_Low(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmailAT returns EmailAT
	 *
	 * Constraint:
	 *     email+=AT
	 */
	protected void sequence_EmailAT(ISerializationContext context, EmailAT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtBracketSentenceC returns ExtBracketSentence
	 *
	 * Constraint:
	 *     (
	 *         open=EXBRC_O 
	 *         (brackedSentences+=FreeSentence (separator+=FullStop brackedSentences+=FreeSentence)*)? 
	 *         (separator+=DOT | separator+=FS | separator+=FullStop)? 
	 *         close=EXBRC_CL
	 *     )
	 */
	protected void sequence_ExtBracketSentenceC(ISerializationContext context, ExtBracketSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtBracketSentence returns ExtBracketSentence
	 *
	 * Constraint:
	 *     (
	 *         open=EXBR_O 
	 *         (brackedSentences+=FreeSentence (separator+=FullStop brackedSentences+=FreeSentence)*)? 
	 *         (separator+=DOT | separator+=FS | separator+=FullStop)? 
	 *         close=EXBR_CL
	 *     )
	 */
	protected void sequence_ExtBracketSentence(ISerializationContext context, ExtBracketSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns ExtBracketSentence
	 *     Brackets returns ExtBracketSentence
	 *     NoNElementX returns ExtBracketSentence
	 *     NoNElementX2 returns ExtBracketSentence
	 *     Elements returns ExtBracketSentence
	 *     AllElements returns ExtBracketSentence
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             open=EXBR_O 
	 *             (brackedSentences+=FreeSentence (separator+=FullStop brackedSentences+=FreeSentence)*)? 
	 *             (separator+=DOT | separator+=FS | separator+=FullStop)? 
	 *             close=EXBR_CL
	 *         ) | 
	 *         (
	 *             open=EXBRC_O 
	 *             (brackedSentences+=FreeSentence (separator+=FullStop brackedSentences+=FreeSentence)*)? 
	 *             (separator+=DOT | separator+=FS | separator+=FullStop)? 
	 *             close=EXBRC_CL
	 *         )
	 *     )
	 */
	protected void sequence_ExtBracketSentence_ExtBracketSentenceC(ISerializationContext context, ExtBracketSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockElement returns FootNote
	 *     FootNote returns FootNote
	 *
	 * Constraint:
	 *     (number=simpleNum SentenceChain=SentenceChain)
	 */
	protected void sequence_FootNote(ISerializationContext context, FootNote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.FOOT_NOTE__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.FOOT_NOTE__NUMBER));
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.FOOT_NOTE__SENTENCE_CHAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.FOOT_NOTE__SENTENCE_CHAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFootNoteAccess().getNumberSimpleNumParserRuleCall_0_0(), semanticObject.getNumber());
		feeder.accept(grammarAccess.getFootNoteAccess().getSentenceChainSentenceChainParserRuleCall_2_0(), semanticObject.getSentenceChain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns Formula
	 *     NoNElementX returns Formula
	 *     NoNElementX2 returns Formula
	 *     Elements returns Formula
	 *     AllElements returns Formula
	 *     Formula returns Formula
	 *
	 * Constraint:
	 *     (name+=EmailAT? (name+=ItWord | name+=Word) parameters+=BracketSentence ((name+=ItWord | name+=Word) parameters+=BracketSentence)*)
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FreeSentence returns Sentence
	 *
	 * Constraint:
	 *     (subsentence+=FreeSubSentence subsentence+=FreeSubSentence*)
	 */
	protected void sequence_FreeSentence(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FreeSubSentence returns SubSentence
	 *
	 * Constraint:
	 *     (elements+=New_Line* elements+=AllElements (elements+=New_Line* elements+=AllElements)* elements+=New_Line*)
	 */
	protected void sequence_FreeSubSentence(ISerializationContext context, SubSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns Unit
	 *     NoNElementX returns Unit
	 *     HashNumber returns Unit
	 *
	 * Constraint:
	 *     ((sign=HASH | sign=PARAGR) value+=Number)
	 */
	protected void sequence_HashNumber(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockElement returns IgnoredText
	 *     NoNElement returns IgnoredText
	 *     NoNElementX returns IgnoredText
	 *     NoNElementX2 returns IgnoredText
	 *     Elements returns IgnoredText
	 *     AllElements returns IgnoredText
	 *     IgnoredText returns IgnoredText
	 *
	 * Constraint:
	 *     ignored=IGNORED
	 */
	protected void sequence_IgnoredText(ISerializationContext context, IgnoredText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.IGNORED_TEXT__IGNORED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.IGNORED_TEXT__IGNORED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIgnoredTextAccess().getIgnoredIGNOREDTerminalRuleCall_0(), semanticObject.getIgnored());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns ItWord
	 *     NoNElementX returns ItWord
	 *     NoNElementX2 returns ItWord
	 *     Elements returns ItWord
	 *     AllElements returns ItWord
	 *     ItWord returns ItWord
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 (
	 *                     ((word+=SeparatorsIt+ | word+=HashP | word+=MULTI | word+=CURRENCY) (word+=ItWordElXx | word+=Fragment)) | 
	 *                     word+=ItWordEl | 
	 *                     word+=CURL | 
	 *                     (word+=ALL_ALPHA word+=COLON)
	 *                 ) 
	 *                 (word+=AllSep+ word+=ItWordElXx)*
	 *             ) | 
	 *             ((word+=Fragment | word+=Asterisk) ((word+=SeparatorsIt+ word+=ItWordElXx) | (word+=AllSep+ word+=ItWordElX)) (word+=AllSep+ word+=ItWordElXx)*)
	 *         ) 
	 *         word+=AllSep*
	 *     )
	 */
	protected void sequence_ItWord(ISerializationContext context, ItWord semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LineSentenceChain returns SentenceChain
	 *
	 * Constraint:
	 *     (sentences+=LineSentence (separators+=FULL_STOP_IM sentences+=LineSentence)* endpoint=FULL_STOP_IM?)
	 */
	protected void sequence_LineSentenceChain(ISerializationContext context, SentenceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LineSentence returns Sentence
	 *
	 * Constraint:
	 *     (subsentence+=LineSubSentence subsentence+=LineSubSentence*)
	 */
	protected void sequence_LineSentence(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LineSubSentence returns SubSentence
	 *
	 * Constraint:
	 *     (elements+=Elements elements+=Elements*)
	 */
	protected void sequence_LineSubSentence(ISerializationContext context, SubSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockElement returns ListSentence
	 *     ListSentence returns ListSentence
	 *
	 * Constraint:
	 *     (listpoint=ListPoint SentenceChain=SentenceChainX?)
	 */
	protected void sequence_ListSentence(ISerializationContext context, ListSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns MailAdress
	 *     NoNElementX returns MailAdress
	 *     NoNElementX2 returns MailAdress
	 *     Elements returns MailAdress
	 *     AllElements returns MailAdress
	 *     MailAdress returns MailAdress
	 *
	 * Constraint:
	 *     ((email+=ItWord | email+=Word) email+=EmailAT email+=ItWord)
	 */
	protected void sequence_MailAdress(ISerializationContext context, MailAdress semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     sentences+=SentenceType+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllElements returns Elements
	 *     New_Line returns Elements
	 *
	 * Constraint:
	 *     nl=NEWLINE
	 */
	protected void sequence_New_Line(ISerializationContext context, Elements semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.ELEMENTS__NL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.ELEMENTS__NL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNew_LineAccess().getNlNEWLINETerminalRuleCall_1_0(), semanticObject.getNl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParagraphBlock returns ParagraphBlock
	 *
	 * Constraint:
	 *     block+=BlockElement+
	 */
	protected void sequence_ParagraphBlock(ISerializationContext context, ParagraphBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceType returns ParagraphBlock
	 *
	 * Constraint:
	 *     (block+=BlockElement+ pEnd=Paragraph)
	 */
	protected void sequence_ParagraphBlock_SentenceType(ISerializationContext context, ParagraphBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns Quote
	 *     NoNElementX returns Quote
	 *     NoNElementX2 returns Quote
	 *     Elements returns Quote
	 *     AllElements returns Quote
	 *     Quote returns Quote
	 *
	 * Constraint:
	 *     quote=STRING
	 */
	protected void sequence_Quote(ISerializationContext context, Quote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.QUOTE__QUOTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.QUOTE__QUOTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuoteAccess().getQuoteSTRINGTerminalRuleCall_0(), semanticObject.getQuote());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenceChainX returns SentenceChain
	 *
	 * Constraint:
	 *     (sentences+=Sentence (separators+=FULL_STOP_IM sentences+=SentenceX)* (endpoint=FULL_STOP_NL | endpoint=NEWLINE | endpoint=KOMMA))
	 */
	protected void sequence_SentenceChainX(ISerializationContext context, SentenceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockElement returns SentenceChain
	 *     SentenceChain returns SentenceChain
	 *
	 * Constraint:
	 *     (sentences+=Sentence (separators+=FULL_STOP_IM sentences+=SentenceX)* (endpoint=FULL_STOP_NL | endpoint=NEWLINE))
	 */
	protected void sequence_SentenceChain(ISerializationContext context, SentenceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceType returns Table
	 *
	 * Constraint:
	 *     (lines+=TableLine lines+=TableRow+ (lines+=TableLine lines+=TableRow+)* lines+=TableLine pEnd=Paragraph)
	 */
	protected void sequence_SentenceType_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceX returns Sentence
	 *
	 * Constraint:
	 *     (subsentence+=TrailSubSentence subsentence+=TrailSubSentence*)
	 */
	protected void sequence_SentenceX(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Sentence
	 *
	 * Constraint:
	 *     (subsentence+=SubSentence subsentence+=TrailSubSentence*)
	 */
	protected void sequence_Sentence(ISerializationContext context, Sentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns ShortCut
	 *     NoNElementX returns ShortCut
	 *     NoNElementX2 returns ShortCut
	 *     Elements returns ShortCut
	 *     AllElements returns ShortCut
	 *     ShortCut returns ShortCut
	 *
	 * Constraint:
	 *     (shortcut=ShortcutLib | shortcut=ShortcutGen)
	 */
	protected void sequence_ShortCut(ISerializationContext context, ShortCut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShortcutGen returns EString
	 *
	 * Constraint:
	 *     ((word+=ALL_ALPHA | word+=ALPHA) (word+=DOT (word+=ALL_ALPHA | word+=ALPHA))+ word+=DOT)
	 */
	protected void sequence_ShortcutGen(ISerializationContext context, EString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShortcutLib returns EString
	 *
	 * Constraint:
	 *     shortcut=SHORTCUTS
	 */
	protected void sequence_ShortcutLib(ISerializationContext context, EString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.ESTRING__SHORTCUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.ESTRING__SHORTCUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortcutLibAccess().getShortcutSHORTCUTSTerminalRuleCall_1_0(), semanticObject.getShortcut());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NoNElementX2 returns SimpleUnit
	 *     Elements returns SimpleUnit
	 *     AllElements returns SimpleUnit
	 *     SimpleUnit returns SimpleUnit
	 *
	 * Constraint:
	 *     (value+=ItNum | value+=HEX_NUMBER)
	 */
	protected void sequence_SimpleUnit(ISerializationContext context, SimpleUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleUnit returns Unit
	 *
	 * Constraint:
	 *     value+=chapterNum
	 */
	protected void sequence_SimpleUnit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSentence returns SubSentence
	 *
	 * Constraint:
	 *     (
	 *         ((elements+=NoNElement elements+=Elements*) | (elements+=NoNElementX elements+=Elements+)) 
	 *         (elements+=New_Line elements+=NoNElementX2 elements+=Elements*)*
	 *     )
	 */
	protected void sequence_SubSentence(ISerializationContext context, SubSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns Symbols
	 *     NoNElementX returns Symbols
	 *     NoNElementX2 returns Symbols
	 *     SymbolsX returns Symbols
	 *
	 * Constraint:
	 *     symbol=SpecialSymbols
	 */
	protected void sequence_SymbolsX(ISerializationContext context, Symbols semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.SYMBOLS__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.SYMBOLS__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolsXAccess().getSymbolSpecialSymbolsParserRuleCall_1_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbols returns Symbols
	 *
	 * Constraint:
	 *     symbol=SpecialCh
	 */
	protected void sequence_Symbols(ISerializationContext context, Symbols semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.SYMBOLS__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.SYMBOLS__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolsAccess().getSymbolSpecialChParserRuleCall_1_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Elements returns Symbols
	 *     AllElements returns Symbols
	 *
	 * Constraint:
	 *     (symbol=SpecialSymbols | symbol=SpecialCh)
	 */
	protected void sequence_Symbols_SymbolsX(ISerializationContext context, Symbols semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableBorder returns TableColumnSeparator
	 *     TableColumnSeparator returns TableColumnSeparator
	 *
	 * Constraint:
	 *     char=HORIZ_SEP
	 */
	protected void sequence_TableColumnSeparator(ISerializationContext context, TableColumnSeparator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.TABLE_COLUMN_SEPARATOR__CHAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.TABLE_COLUMN_SEPARATOR__CHAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableColumnSeparatorAccess().getCharHORIZ_SEPTerminalRuleCall_0(), semanticObject.getChar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TableLine returns TableLine
	 *     TableBorder returns TableLine
	 *
	 * Constraint:
	 *     content=TABLE_LINE
	 */
	protected void sequence_TableLine(ISerializationContext context, TableLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NaturalLangPackage.Literals.TABLE_LINE__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NaturalLangPackage.Literals.TABLE_LINE__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableLineAccess().getContentTABLE_LINETerminalRuleCall_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (content+=TableBorder content+=LineSentenceChain? (content+=TableBorder content+=LineSentenceChain?)* content+=TableBorder)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (lines+=TableLine lines+=TableRow+ (lines+=TableLine lines+=TableRow+)* lines+=TableLine)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrailSubSentence returns SubSentence
	 *
	 * Constraint:
	 *     (elements+=Elements elements+=Elements* (elements+=New_Line elements+=NoNElementX2 elements+=Elements*)*)
	 */
	protected void sequence_TrailSubSentence(ISerializationContext context, SubSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (signature=MINUS? value+=Number (unit=CURRENCY | unit=ID | unit=PERCENT)?)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns UrlAdress
	 *     NoNElementX returns UrlAdress
	 *     NoNElementX2 returns UrlAdress
	 *     Elements returns UrlAdress
	 *     AllElements returns UrlAdress
	 *     UrlAdress returns UrlAdress
	 *
	 * Constraint:
	 *     (protocol=URL_PROTOCOL url+=ItWordElurl (url+=AllSep+ (url+=ItWordElXx | url+=simpleNum | url+=Fragment))* url+=AllSep*)
	 */
	protected void sequence_UrlAdress(ISerializationContext context, UrlAdress semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordShort returns Word
	 *
	 * Constraint:
	 *     word+=ALPHA
	 */
	protected void sequence_WordShort(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElement returns Word
	 *     NoNElementX2 returns Word
	 *     Word returns Word
	 *
	 * Constraint:
	 *     ((word+=FragmentX | (word+=Fragment (word+=SeparatorsL word+=Fragment)+)) word+=SeparatorsL?)
	 */
	protected void sequence_Word(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoNElementX returns Word
	 *     Elements returns Word
	 *     AllElements returns Word
	 *
	 * Constraint:
	 *     (((word+=FragmentX | (word+=Fragment (word+=SeparatorsL word+=Fragment)+)) word+=SeparatorsL?) | word+=ALPHA)
	 */
	protected void sequence_Word_WordShort(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
