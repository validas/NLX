/*
 * generated by Xtext 2.16.0
 */
package de.validas.spedit.validation

import com.google.inject.Inject
import de.validas.nlx.dictionary.IDictionaryAccess
import de.validas.nlx.dictionary.util.LogUtils
import de.validas.spedit.naturalLang.Elements
import de.validas.spedit.naturalLang.NaturalLangPackage
import de.validas.spedit.naturalLang.Sentence
import de.validas.spedit.naturalLang.SubSentence
import de.validas.spedit.naturalLang.Word
import de.validas.spedit.validation.semantics.ImplicitRulesOnDict
import de.validas.utils.data.types.XPair
import java.util.List
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.builder.debug.IBuildLogger
import org.eclipse.xtext.util.EmfFormatter
import org.eclipse.xtext.validation.Check

import static de.validas.spedit.constants.NaturalLangConstants._CAPITALIZE_NAME
import static de.validas.spedit.constants.NaturalLangConstants._MATCH_PATTERN
import static de.validas.spedit.constants.NaturalLangConstants._TRAIN_DICT
import static de.validas.spedit.constants.NaturalLangConstants._TRAIN_TYPE
import static de.validas.spedit.constants.NaturalLangConstants._TYPO

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class NaturalLangValidator extends AbstractNaturalLangValidator {
	/**
	 * idetifiers for Annotations
	 */
//	public static val TYPO = 'Typography'
//	public static val INVALID_NAME = 'invalidName'
//	public static val TRAIN_DICT = 'trainDictionary'
	
	//TODO: To be externalized
//	val _CAPITALIZE_NAME = "Word should start with a capital"
//	val _TRAIN_TYPE = "Word type for \"%s\" \nnot trained"
//	val _MATCH_PATTERN = "[a-zA-ZäöüÄÖÜêÊéÉèÈóÓòÒûÛôÔ]+"
	
	@Inject
	IDictionaryAccess dictAcc;
	
	@Inject
	protected IBuildLogger buildLogger;
	protected ImplicitRulesOnDict semantics
	
	//protected static Logger LOGGER = Logger.getLogger(NaturalLangValidator);
	
	//TODO: consider @Inject 
	protected LogUtils logUtil = new LogUtils(buildLogger);
	
// TODO: to be replaced by preferences Entry
	boolean val_CAPITALIZE_PREF_ON = true;
	boolean val_DICT_PREF_ON = true
	boolean pref_IMPLICIT_SEMANTICS = false

	@Check
	def checkWordIsInDict(Elements element) {
		if (val_DICT_PREF_ON) {
			//TODO: try to find Marker to Position before accessing the dictionary
			var path = EmfFormatter.objPath(element)
			if (element instanceof Word) {
				if (!dictAcc.isConnected())
					return;
				for (fragment : element.word) {
					if (fragment !== null && fragment.matches(_MATCH_PATTERN)) {
						var result = dictAcc.findInDictionary(fragment)
						if (result === null)
							info(String.format(_TRAIN_TYPE, fragment), NaturalLangPackage.Literals.WORD__WORD, _TRAIN_DICT, fragment)
					}
				}
			}
		} else {
			logUtil.logAccess("Dict PREF", 1, "Dictionary Disabled");
		}
	}

	@Check
	def checkSentenceStartsWithUpperCase(SubSentence ssentence) {
		if (val_CAPITALIZE_PREF_ON) {
			var elList = (ssentence.elements as Object) as EList<EObject> ?: new BasicEList();
			if (elList.isEmpty) return;
			var sentence = ssentence.eContainer as Sentence;
			if (!sentence.subsentence.get(0).equals(ssentence)) return;
			// val EList<New_Line> elements = ssentence.elements
			var el0 = ssentence.elements.get(0) as EObject;
			if (el0 instanceof Word)
				if (!Character.isUpperCase(el0.word.get(0).charAt(0))) {
					warning(_CAPITALIZE_NAME, NaturalLangPackage.Literals.SUB_SENTENCE__ELEMENTS, _TYPO, el0.word)
				}
		} else {
			logUtil.logAccess("Validate", 1, "Typography Disabled");
		}
	}

	/**
	 * does start implicit checks with a rule database to improve Dictionary
	 */
	@Check
	def semanticChecksSentence(Sentence sentence) {
		if (pref_IMPLICIT_SEMANTICS) {
			init_implRuleSet()
			var fullChain = semantics.generateChain(sentence)
			if (semantics.checkAllWordsTrained(fullChain)) {
				semantics.implicitRuleOnSentence(sentence, fullChain)
			}
		} else {
			logUtil.logAccess("Validate", 1, "Implicit grammar rule checker: disabled!");
		}
	}

	def init_implRuleSet() {
		if (semantics === null && buildLogger !== null)
			semantics = new ImplicitRulesOnDict(dictAcc, buildLogger)
	}	
	
}
