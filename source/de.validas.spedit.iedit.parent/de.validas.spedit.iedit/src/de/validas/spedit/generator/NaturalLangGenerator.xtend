/*
 * generated by Xtext 2.16.0
 */
package de.validas.spedit.generator

import com.google.common.collect.Iterators
import com.google.inject.Inject
import de.validas.spedit.generator.utils.NlxGeneratorUtil
import de.validas.spedit.generator.utils.ReflectiveUtils
import de.validas.spedit.naturalLang.BlockElement
import de.validas.spedit.naturalLang.BracketSentence
import de.validas.spedit.naturalLang.ChapterSentence
import de.validas.spedit.naturalLang.EString
import de.validas.spedit.naturalLang.Elements
import de.validas.spedit.naturalLang.FootNote
import de.validas.spedit.naturalLang.IgnoredText
import de.validas.spedit.naturalLang.ItWord
import de.validas.spedit.naturalLang.LineSentence
import de.validas.spedit.naturalLang.LineSentenceChain
import de.validas.spedit.naturalLang.ListSentence
import de.validas.spedit.naturalLang.MailAdress
import de.validas.spedit.naturalLang.Model
import de.validas.spedit.naturalLang.New_Line
import de.validas.spedit.naturalLang.ParagraphBlock
import de.validas.spedit.naturalLang.Quote
import de.validas.spedit.naturalLang.Sentence
import de.validas.spedit.naturalLang.SentenceChain
import de.validas.spedit.naturalLang.SentenceX
import de.validas.spedit.naturalLang.ShortCut
import de.validas.spedit.naturalLang.SubSentence
import de.validas.spedit.naturalLang.Symbols
import de.validas.spedit.naturalLang.Table
import de.validas.spedit.naturalLang.TableColumnSeparator
import de.validas.spedit.naturalLang.TableLine
import de.validas.spedit.naturalLang.TableRow
import de.validas.spedit.naturalLang.Unit
import de.validas.spedit.naturalLang.UrlAdress
import de.validas.spedit.naturalLang.Word
import de.validas.utils.data.lists.IAppendable
import de.validas.utils.data.lists.LinkedList
import de.validas.utils.data.lists.XList
import de.validas.utils.io.filesystem.File
import de.validas.utils.io.filesystem.Path
import java.util.HashMap
import java.util.List
import java.util.regex.Pattern
import metaModel.referenceProcess.Process
import metaModel.referenceProcess.ReferenceProcessFactory
import metaModel.referenceProcess.RequiredDocument
import metaModel.referenceProcess.Requirement
import metaModel.suptertype.Named
import org.apache.commons.lang.math.NumberUtils
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.TreeIterator
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.xmi.XMLResource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.ILocationInFileProvider

import static de.validas.spedit.constants.NaturalLangConstants.*
import static de.validas.spedit.constants.NaturalLangMessages.*
import static de.validas.spedit.generator.utils.ReflectiveUtils.getAllChildrenRecursive

import static extension org.eclipse.xtext.nodemodel.util.NodeModelUtils.*
import de.validas.spedit.naturalLang.ExtBracketSentence
import org.eclipse.xtext.util.LineAndColumn
import java.util.regex.Matcher
import java.util.Collections
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NaturalLangGenerator extends AbstractGenerator {

	@Inject
	protected ILocationInFileProvider locationInFileProvider;

	protected boolean content_table = true

	/**
	 * 
	 */
	
	Context context
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var absoluteLocation = NlxGeneratorUtil.findResourceInWS(resource)
		var documentPath = new Path(absoluteLocation.toOSString)
		var file = documentPath.getLastPathElement()
		if (file instanceof File) {
			(file as File).extension = MODEL_EXTENSION
		}
		var URI fileURI = URI.createFileURI(documentPath.toFilePath.absolutePath)
		var modelResource = createModelResource(fileURI)
		var process = generateRequirementModel(resource.allContents)
		if (process !== null) {
			modelResource.getContents().add(process);
		}
		createLinksRecursive(process.requirements)
		removeLinkReferences(process)
		saveModelResource(modelResource)
	}

	/**
	 * 
	 */
	protected def createLinksRecursive(EList<Requirement> requirements) {
		var referenceMap = newHashMap();
		recursiveRequirementMapper(requirements, referenceMap)
		recursiveRequirementConnector(null, requirements, referenceMap)
	}

	/**
	 * 
	 */
	protected def removeLinkReferences(Process process) {
		var classTypes = new XList<Class<?>>();
		classTypes.add(RequiredDocument);
		var allNodes = ReflectiveUtils.getAllChildren(process, classTypes, true);
		for (EObject node : allNodes) {
			if (!(node as Named).name.startsWith(DESC_UNRESOLVED))
				EcoreUtil.delete(node, false); // keep unresolved Links
		}
	}

	/**
	 * 
	 */
	protected def void recursiveRequirementConnector(Requirement parent, EList<Requirement> reqList, HashMap<String, List<Requirement>> map) {
		for (Requirement req : reqList) {
			if (!(req instanceof RequiredDocument)) {
				if (!( req.subRequirements === null || req.subRequirements.isEmpty())) {
					recursiveRequirementConnector(req, req.subRequirements, map)
				}
			} else {
				if (map.containsKey(req.ID) && parent !== null) {
					var linkedReq = new ArrayList<Requirement>(map.get(req.ID)).map[r | if (r.description?.equals(_FOOTNOTE)){
						var childLine = getPositionInfo(r.comment)?.line
						var parentLine = getPositionInfo(parent.comment)?.line
						if (Math.abs(childLine-parentLine)<100)
							return r
					} else return r 
					return null  ]
					linkedReq?.removeAll(Collections.singleton(null))
					if (linkedReq!==null)
						parent.requiredRequirements.addAll(linkedReq)
				// EcoreUtil.delete(req, true);
				} else {
					req.name = DESC_UNRESOLVED
				}
			}
		}
	}
	
	def LineAndColumn getPositionInfo(String string) {
		if (string === null)
			return null
		if (string.empty) 
				return null	
		val regex = _LINE_POSITION_REGEX
		val Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
        val Matcher matcher = pattern.matcher(string);
        while (matcher.find()) {
        	try {
            	var line = Integer.parseInt(matcher.group('line'))
            	var column = Integer.parseInt(matcher.group('column'))
            	if (line != 0 && column != 0)
            		return LineAndColumn.from(line, column) 		
            } catch (IllegalArgumentException e) {
            	return null
            }
        }
        null
	}

	/**
	 * 
	 */
	protected def void recursiveRequirementMapper(EList<Requirement> reqList, HashMap<String, List<Requirement>> map) {
		for (Requirement req : reqList) {
			if (!(req instanceof RequiredDocument) && req.ID !== null) {
				var ID = req.ID
				if (map.containsKey(ID))
					map.get(ID).add(req)
				else
					map.put(ID, newArrayList(req))
				if (!( req.subRequirements === null || req.subRequirements.isEmpty())) {
					recursiveRequirementMapper(req.subRequirements, map)
				}
			}
		}
	}

	/**
	 * 
	 */
	def saveModelResource(Resource modelResource) {
		// Save the contents of the resource to the file system.
		//
		var options = new HashMap<Object, Object>();
		options.put(XMLResource.OPTION_ENCODING, ENCODING);
		modelResource.save(options);
	}

	def Resource createModelResource(URI fileURI) {
		var resourceSet = new ResourceSetImpl();
		return resourceSet.createResource(fileURI);
	}

	/*
	 * 
	 */
	def Process generateRequirementModel(TreeIterator<EObject> iterator) {
		var process = ReferenceProcessFactory.eINSTANCE.createProcess();
		
		context = new Context()
		
		// requirementPointer. Pointing to the current working requirement-object:
		var requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
		process.getRequirements().add(requirementObj);
		requirementObj.name = _INTRODUCTION
		requirementObj.ID = "0"
		requirementObj.description = _INTRO_DESC
		var model = getRoot(iterator) as Model
		var elements = new java.util.LinkedList(model.eContents())
		var EObject last = null
		var pIterator = Iterators.peekingIterator(elements.iterator)
		
		while (pIterator.hasNext) {
			var EObject element = pIterator.next
			var EObject peek = null
			if (pIterator.hasNext) {
				peek = pIterator.peek
			}
			switch (element){
				ParagraphBlock: {
					var pair = paragraphToString(element, requirementObj);
					var text = pair.key
					requirementObj = pair.value
					buildLongDescrSentence(requirementObj, text)
				}
				ChapterSentence: {
					if (!isContentTable(peek, element, last) || !content_table) {
						content_table = false
						requirementObj = newRequirementObj(requirementObj, element)
						requirementObj.name = lineSentenceChainToString(element.headline as SentenceChain, requirementObj)
					} else {
						var headline = new StringBuilder(UnitToString(element.chapterNumber as Unit, requirementObj, false))
						headline.append(' ')  
						headline.append(lineSentenceChainToString(element.headline as SentenceChain, requirementObj))
						headline.append(_NEW_LINE)
						buildLongDescrSentence(requirementObj, headline.toString())
					}
				}
				Table: {
					var String text = TableToString(element, requirementObj);
					buildLongDescrSentence(requirementObj, text)
				}
			}
			last = element
		}
		return process;
	}
	
	def isContentTable(EObject peek, ChapterSentence el, EObject last) {
		var lastT = false
		if (last instanceof ChapterSentence) 
			lastT = true
			
		var elms = newArrayList()
		for(sents: (el.headline as SentenceChain).sentences ){
			for (subs : (sents as Sentence).subsentence)
				elms.addAll((subs as SubSentence).elements)
		}
		if (elms.size>2){
			if (elms.get(elms.size-2) instanceof IgnoredText){
				content_table = true
				return true
			}
		}
		
		if (peek instanceof ChapterSentence && lastT)
			return true
	
		false
	}

	def Requirement newRequirementObj(Requirement origRequirement, EObject element) {
		var requirementObj = ReferenceProcessFactory.eINSTANCE.createRequirement();
		var process = EcoreUtil.getRootContainer(origRequirement)
		requirementObj.comment = getPosition(element)
		var Named parent
		if (process instanceof Process) {
			var chapter_num = ""
			switch element {
				ChapterSentence: {
					 chapter_num = (element.chapterNumber as Unit).value.join
					 requirementObj.ID = chapter_num;
					 context = new Context()	
					 parent = findParentChapter(process, requirementObj.ID)
					 requirementObj.description = _SUB_CHAPTER
				}
				ListSentence: {
					chapter_num = element.listpoint
					var parentID = origRequirement.ID
					if (parentID === null)
						return origRequirement
					var String num
					var pattern = Pattern.compile(_REGEX_PATTERN);  //TODO: opposite match (bullet points)
					var matcher = pattern.matcher(chapter_num);
					if (matcher.find()) {
						num = matcher.group(0)
						parentID += "."
					} else {
						if (context !== null){
							num = NlxGeneratorUtil.getNumeric(chapter_num)
							if (num !== null){
								context.setLeading(NlxGeneratorUtil.StrToNum(num))
							} else {
								context.incTrailing()
							}
						}
	
						parentID += _DASH
						num = context.generate
					}
					parentID += num
					requirementObj.ID = parentID
					requirementObj.description = _SUB_REQUIREMENT //"Sub Requirement"
					parent = origRequirement
				}
				FootNote: {
					requirementObj.ID = '''«element.number»'''
					requirementObj.description = _FOOTNOTE //"Footnote"
					parent = origRequirement
				}
				default:{
					requirementObj.ID = chapter_num;
					requirementObj.description = _SUB_CHAPTER //"Sub Chapter"
					context = new Context()
					parent = origRequirement
				}
			}
			
			if (parent instanceof Requirement) {
				parent.subRequirements.add(requirementObj)				
			} else {
				process.requirements.add(requirementObj)
				requirementObj.description = _MAIN_CHAPTER //"Main Chapter"
			}
			return requirementObj
		} else {
			return origRequirement
		}
	}

	def TableToString(Table table, Requirement requirement) {
		var sb = new StringBuilder();
		var List<Integer> columns = #[]
		for (EObject elm : table.lines) {
			if (elm instanceof TableLine) {
				columns = configureTable(elm.content)
				sb.append(elm.content)
			} else if (elm instanceof TableRow) {
				var result = TableRowToString(elm, requirement, columns)
				sb.append(result.key)
				columns = result.value
			}
			sb.append(_NEW_LINE);
		}
		return sb.toString
	}

	def List<Integer> configureTable(String headline) {
		val char plus = '+'
		val char minus = '-'
		var columns = newArrayList()
		var column = 0 // TODO: obsolete
		var len = 0
		var firstborder = true
		for (char elm : headline.toCharArray) {
			switch elm {
				case plus: {
					if (firstborder)
						firstborder = false
					else {
						columns.add(len)
						column++
						len = 0
					}
				}
				case minus: {
					len++
				// columns.set(column, len)
				}
			}
		}
		columns
	}

	def TableRowToString(TableRow row, Requirement requirement, List<Integer> columns) {
		var intColumns = columns
		var StringBuilder sb = new StringBuilder();
		var column = 0;
		var firstborder = true
		var EObject last = null
		var index = 0
		for (EObject elm : row.content) {   //TODO: 11.10.21 Table generation Buggy
			if (elm instanceof TableColumnSeparator) {
				if (firstborder)
					firstborder = false
				else
					column++
				if (last instanceof TableColumnSeparator || last instanceof TableLine) {
					sb.append(createCellContent('', intColumns, column - 1))
				}
				sb.append(elm.char)
			} else if (elm instanceof TableLine) {
				var blankLine = configureTable(elm.content)
				if (last instanceof TableColumnSeparator || last instanceof TableLine) {
					sb.append(createCellContent('', intColumns, column))
				}
				intColumns = replaceColumns(row.content, intColumns, blankLine, index)
				column += blankLine.size
				sb.append(elm.content)
			} else if (elm instanceof SentenceChain) {
				var String content = createCellContent(lineSentenceChainToString(elm, requirement), intColumns, column)  //TODO: wrong column calculation
				sb.append(content)
			}
			last = elm
			index++
		}
		return new Pair<String, List<Integer>>(sb.toString, intColumns)
	}

	def replaceColumns(EList<EObject> row, List<Integer> columns, List<Integer> columnsIM, int index) {
		var last = row.size()
		var colMax = columns.size()-1
		for (var i = index; i < row.size(); i++) {
			var token = row.get(i)
			if (token instanceof TableColumnSeparator)
				last--
		}
		var List<Integer> result = columns.subList(0, Math.min(index,colMax)) //TODO: 11.10.21: index out of bounds bug
		result += columnsIM
		if (last < row.size())
			result += columns.subList(Math.min(last,colMax), Math.min(row.size(),colMax))   //TODO: 11.10.21 fix index out of bounds
		result
	}

	def createCellContent(String content, List<Integer> columns, int column) {
		//TODO: 11.10.21 index out of bounds:
		
		var length = columns.get(Math.min(column,columns.size()-1)) - 1
		String.format(''' %-«length».«length»s''', content);
	}

	def lineSentenceChainToString(SentenceChain chain, Requirement requirement) {
		var int i = 0
		var StringBuilder sb = new StringBuilder();
		for (EObject token : chain.sentences)
			if (token instanceof LineSentence) {
				sb.append(sentenceToString(token as Sentence, requirement,0, 0))
				if (chain.separators.size() > i)
					sb.append(chain.separators.get(i))
			}
		if (chain.endpoint !== null && !chain.endpoint.empty) {
			sb.append(chain.endpoint)
		} 
//		else {
//			sb.append(_NEW_LINE)
//		} 
		return sb.toString
	}

	protected def paragraphToString(ParagraphBlock block, Requirement requirement) {
		//var internalReq = requirement
		var StringBuilder sb = new StringBuilder();
		//var sb = ''''''
		for (BlockElement elm : block.block)
			switch (elm){
				SentenceChain:{
					sb.append(sentenceChainToString(elm, requirement, 0))
				}
				ListSentence: {
					var pair = listSentenceToString(elm, requirement)
					pair.value.requiredByRequirements.add(requirement)
					requirement.requiredRequirements.add(pair.value)
					
					sb.append('''«_LIST_REPLACEMENT_MSS» «pair.value.ID»)«_NEW_LINE»''')
					//internalReq = pair.value
				}
				FootNote: {
					var pair = footNoteToString(elm, requirement)
					pair.value.requiredByRequirements.add(requirement)
					requirement.requiredRequirements.add(pair.value)
					sb.append('''«_FOOT_NOTE_MSS» «pair.value.ID»)«_NEW_LINE»''')
				}
				IgnoredText:{
					//Ignore 
				}
			}
			
		if (block.PEnd !== null)
			sb.append(block.PEnd) // weather paragraph gap with '.' at the end or not 
		return new Pair<String, Requirement>(sb.toString,requirement)
	}
	
	def footNoteToString(FootNote note, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, note)
		if (internalReq != requirement)
			internalReq.name = '''[Footnote] «sentenceChainToString(note.sentenceChain, requirement, NAME_MIN_LEN)»''' //TODO: strip new line
			
		var str ='''«sentenceChainToString(note.sentenceChain, requirement, 0)»'''
		buildLongDescrSentence(internalReq, str)
		return new Pair<String, Requirement>(str,internalReq)
	}

	protected def listSentenceToString(ListSentence sentence, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, sentence)
		if (internalReq != requirement)
			internalReq.name = sentenceChainToString(sentence.sentenceChain as SentenceChain, null, NAME_MIN_LEN) //TODO: strip new line
			
		var str ='''«sentenceChainToString(sentence.sentenceChain as SentenceChain, internalReq, 0)»'''
		buildLongDescrSentence(internalReq, str)
		return new Pair<String, Requirement>(str,internalReq)
	}

	protected def sentenceChainToString(SentenceChain chain, Requirement requirement, int len){
		if (chain === null) return ""
		sentencesToString(chain.sentences, chain.separators, chain.endpoint, requirement, 0,  len)
	}

	protected def sentencesToString(EList<? extends EObject> chain, EList<String> separators, String endpoint, Requirement requirement, int start, int len) {
		var StringBuilder sb = new StringBuilder();
		var int index = 0
		var int sStart = 0
		if (chain === null) return new String
		var lastSentence = ""
		for (SentenceX sentence : chain as EList<SentenceX>) {  // odd type inferring Sentence->FreeSentence
			if (index > 0){
				if (len > 0 && sb.length> len)
					return sb.toString
				else 
					if (lastSentence.length > 0)
						sb.append(separators.get(index - 1))
				sStart = 0
			} else {
				sStart = start
			}
			lastSentence = sentenceToString(sentence as Sentence, requirement, sStart, len)
			sb.append(lastSentence)
			index++
		}
		if (endpoint !== null) {
			sb.append(endpoint)
		}
		return sb.toString
	}

	def getRoot(TreeIterator<EObject> iterator) {
		if (iterator.hasNext()) {
			return EcoreUtil.getRootContainer(iterator.next())
		} else
			null
	}

	/** 
	 * 
	 */
	protected def void buildLongDescrSentence(Requirement requirementObj, String text) {
		if (requirementObj.longDescription === null)
			requirementObj.longDescription = text
		else
			requirementObj.longDescription = requirementObj.longDescription.concat(text)
	}

	protected def Named findParentChapter(Named parent, String chapter_num) {
		var LinkedList<ChapterNumber> chapter = new LinkedList<ChapterNumber>();
		chapter = createChapterNum(chapter_num)
		var int chapterHierarchy = truncateZeros(chapter)
		if (chapterHierarchy <= 1) {
			return parent
		}
		var XList<Class<?>> diagramClasses = new XList<Class<?>>();
		diagramClasses.add(Named)
		var EList<? extends EObject> allNodes = (getAllChildrenRecursive(parent, diagramClasses))
		var LinkedList<ChapterNumber> parentChapter = chapter.subList(0, chapter.length - 1)
		if (parentChapter.length > 1)
			parentChapter = parentChapter.subList(0, truncateZeros(parentChapter))
		var LinkedList<ChapterNumber> found_Chapter = new LinkedList<ChapterNumber>();
		for (Named node : allNodes as EList<Named>) {
			if (node instanceof Requirement && ! (node instanceof RequiredDocument)) {
				found_Chapter = createChapterNum(node.ID)
				if (compareContent(found_Chapter, parentChapter) && ( #[_SUB_CHAPTER, _MAIN_CHAPTER, _SUB_REQUIREMENT, _INTRO_DESC].contains(node.description?:""))) {
					return node
				}
			}
		}
		return parent
	}

	protected def compareContent(LinkedList<? extends IAppendable> original, LinkedList<? extends IAppendable> comparator) {
		if (original.size != comparator.size) return false;
		var boolean equal = true;
		for (var int i = 0; i < original.size; i++) {
			// TODO: should be negated. positive if is obsolete, because 'equal' never turns into false
			if (equal && (original.get(i) as ChapterNumber).number.equals((comparator.get(i) as ChapterNumber).number))
				equal = true // nonsense, but xtend does not allow continue or break
			else
				return false
		}
		return equal
	}

	protected def int truncateZeros(LinkedList<ChapterNumber> chapter) {
		var int i = chapter.length
		for (; i > 0; i--) {
			var number = (chapter.get(i - 1) as ChapterNumber).number
			if (!(NumberUtils.isNumber(number) && Integer.decode(number) == 0)) return i; //TODO: 01.12.21 decoding numbers errorous: "1d"
		}
		return 0;
	}

	protected def LinkedList<ChapterNumber> createChapterNum(String chapter_num) {
		var LinkedList<ChapterNumber> chapter = new LinkedList<ChapterNumber>()
		if (chapter_num === null || chapter_num.empty) // Return Empty List
			return new LinkedList<ChapterNumber>()
		var String[] tokens = chapter_num.split('\\.')
		for (String token : tokens) {
			chapter.add(new ChapterNumber(token))
		}
		var zeros = truncateZeros(chapter)
		if (zeros > 0) { 
			return chapter.subList(0, zeros) 
		}else
			return chapter
	}

	protected def sentenceToString(Sentence sentence, Requirement requirement,int start, int len) {
		var subS = (sentence as Sentence).subsentence
		if (len > 0 && subS.size > 0)
			return relSubSentenceToString(subS.get(0) as SubSentence, requirement, start, len)
		var str = '''«FOR rSentence : subS SEPARATOR(', ')
						»«relSubSentenceToString(rSentence as SubSentence, requirement, start, 0)»«
					ENDFOR»'''
//					IF sentence.endPoint !== null
//						»«sentence.endPoint»«
//					ENDIF»'''
		str
	}

	protected def String elementToString(Elements element, Requirement requirement, int len) {
		switch element {
			Word: {
				return element.word.join('')
			}
			Unit: {
				return UnitToString(element, requirement, true)
			}
			ShortCut:{
				var scEl = element.shortcut as EString
				return scEl.shortcut ?: scEl.word.join('')
			}
			ItWord:
				return element.word.join('')
			Quote:
				return '''"«element.quote»"'''
			ExtBracketSentence,
			BracketSentence: {
				if (len > 0)
					return sentencesToString(element.brackedSentences, element.separator, null, requirement, 0, len)
				return brackedSentenceToText(element, element.open.charAt(0), element.close.charAt(0), requirement)
			}
			Symbols:
				return element.symbol
			UrlAdress:
				return element.protocol + element.url.join('')
			MailAdress:
				return element.email.join('')
			IgnoredText:
				return element .ignored
			New_Line:
				return element.nl
		}
	}

	def String UnitToString(Unit unit, Requirement requirement, boolean addRequirement) {
		var result = unit.value + unit.unit
		if (requirement == null)
			return result
		for (req : requirement.subRequirements) {
			if (req.ID == result)
				return result
		}
		if (addRequirement)
			addSubRequirement(result, requirement, unit)
		result
	}
	
	def addSubRequirement(String id, Requirement requirement, Unit unit){
		var RequiredDocument reqDocumentNode = ReferenceProcessFactory.eINSTANCE.createRequiredDocument();
		reqDocumentNode.ID = id
		reqDocumentNode.name = _INTERNAL_REF_NODE //"Internal Reference Node"
		reqDocumentNode.longDescription = getPosition(unit) 
		requirement.subRequirements.add(reqDocumentNode)
		requirement
	}
	
	def getPosition(EObject elm) {
		var loc = locationInFileProvider.getSignificantTextRegion(elm)
		var node = elm.node
		var linecol = node.getLineAndColumn(loc.offset)
		var uri =  EcoreUtil.getURI(elm)
		'''Position [Line: «linecol.line» | Column: «linecol.column»]
URI: «uri»'''.toString
	}

	protected def String subSentenceToString(SubSentence ssentence, Requirement requirement, int start, int len) {
		var StringBuilder sb = new StringBuilder();
		var int index = 0
		//var str ='''«FOR element : ssentence.elements SEPARATOR(' ')»«elementToString(element as Elements, requirement)»'''
		for (element : ssentence.elements) {
			if (len>0 && len <= sb.length)
				return sb.toString
			if (index > start)
				sb.append(' ')
			if (index >= start) sb.append(elementToString(element as Elements, requirement, len)) 
			index++
		}
		return sb.toString
	}

	protected def String relSubSentenceToString(SubSentence ssentence, Requirement requirement,int start, int len) {
		return subSentenceToString(ssentence, requirement,start, len)
	}

	protected def String brackedSentenceToText(BracketSentence bs, char startingBr, char endBr, Requirement requirement) {
		var extractName = ""   
		
		var firstEl = getElement(bs, 0)
		if (firstEl != null && (firstEl.equals(_NOTE) || firstEl.equals(_EXAMPLE))){
			extractName =  firstEl
		}
		
		var str = '''«startingBr»«
			IF extractName.length > 0»«
				extractBracket(bs, extractName, requirement)»«
			ELSE»«
				sentencesToString(bs.brackedSentences, bs.separator, null, requirement, 0, 0)»«
			ENDIF»«endBr»'''
		str
	}
	
	def getElement(EObject el, int idx) {
		var EList<Sentence> sentences
		switch (el){
			ExtBracketSentence,
			BracketSentence: {
				sentences = (el.brackedSentences as Object)  as EList<Sentence>
			}
			SentenceChain:{
				sentences = (el.sentences as Object) as EList<Sentence>
			}
		}
		var counter = 0
		for (sentence : sentences ?: #[]){
			
			for (EObject subs : sentence.subsentence ?: #[]){
				if (subs instanceof SubSentence){
					for (elms: subs.elements ?: #[]){
						if (counter == idx)
							return elementToString(elms as Elements, null, 0)
						counter++
					}
				}
			}
		}
	}
	
	def extractBracket(BracketSentence bs, String extractName, Requirement requirement) {
		var internalReq = newRequirementObj(requirement, bs)
		var sentences = bs.brackedSentences
		var sep = bs.separator
		if (internalReq != requirement){
			var id = requirement.ID
			internalReq.ID = '''«id»«IF (id.contains(_DASH))».«ELSE»-«ENDIF»«extractName»'''
			internalReq.name = sentencesToString(sentences, sep, null, null, 1, NAME_MIN_LEN)
			internalReq.description = extractName
			internalReq.longDescription = sentencesToString(sentences, sep, null, internalReq, 1, 0)
			//addToParent(requirement, internalReq)
			requirement.subRequirements.add(internalReq)
			'''«extractName» «_NOTE_REPL_MSS» «internalReq.ID»'''
		} else 
			sentencesToString(sentences, sep, null, internalReq, 0, 0)
	}
	
//	def addToParent(Requirement requirement, Requirement requirementObj) {
//		var process = EcoreUtil.getRootContainer(requirement)
//		if (process instanceof Process){
//			var Named parent = findParentChapter(process, requirement.ID)
//			if (parent instanceof Requirement) {
//				parent.subRequirements.add(requirementObj)				
//			} else {
//				process.requirements.add(requirementObj)	
//			}
//		}
//	}
	
}
